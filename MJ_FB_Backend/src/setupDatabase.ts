import { Client } from 'pg';
import config from './config';
import logger from './utils/logger';

/**
 * Initializes the database if it does not exist.
 * All schema changes must be implemented via migrations in src/migrations.
 * Do not modify this file for schema updates.
 */
export async function setupDatabase() {
  const dbName = config.pgDatabase;
  const dbConfig = {
    user: config.pgUser,
    password: config.pgPassword,
    host: config.pgHost,
    port: config.pgPort,
  };

  // Connect to default database to ensure target database exists
  const adminClient = new Client({ ...dbConfig, database: 'postgres' });
  await adminClient.connect();
  const dbExists = await adminClient.query('SELECT 1 FROM pg_database WHERE datname = $1', [dbName]);
  if ((dbExists.rowCount ?? 0) === 0) {
    const createDbQuery = await adminClient.query(
      "SELECT format('CREATE DATABASE %I', $1::text) AS query",
      [dbName],
    );
    await adminClient.query(createDbQuery.rows[0].query);
    logger.info(`Created database ${dbName}`);
  }
  await adminClient.end();

  // Now connect to the target database
  const client = new Client({ ...dbConfig, database: dbName });
  await client.connect();

  // Create tables if they do not exist
  await client.query(`
CREATE TABLE IF NOT EXISTS slots (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    max_capacity integer NOT NULL,
    UNIQUE (start_time, end_time)
);

CREATE TABLE IF NOT EXISTS clients (
    client_id bigint PRIMARY KEY CHECK (client_id >= 1 AND client_id <= 9999999),
    first_name text,
    last_name text,
    email text UNIQUE,
    phone text,
    password text,
    role text NOT NULL CHECK (role IN ('shopper', 'delivery')),
    profile_link text NOT NULL,
    bookings_this_month integer DEFAULT 0,
    booking_count_last_updated timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    online_access boolean DEFAULT false
);

CREATE TABLE IF NOT EXISTS staff (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    first_name varchar(100) NOT NULL,
    last_name varchar(100) NOT NULL,
    role varchar(50) NOT NULL CHECK (role IN ('staff', 'admin')),
    email varchar(255) NOT NULL UNIQUE,
    password varchar(255),
    access text[] NOT NULL DEFAULT '{}'::text[] CHECK (access <@ ARRAY['pantry','volunteer_management','warehouse','admin','donor_management','payroll_management'])
);
CREATE TABLE IF NOT EXISTS events (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    title text NOT NULL,
    details text,
    category text,
    start_date date NOT NULL,
    end_date date NOT NULL,
    created_by integer NOT NULL REFERENCES public.staff(id),
    visible_to_volunteers boolean NOT NULL DEFAULT false,
    visible_to_clients boolean NOT NULL DEFAULT false,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    updated_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP
);
CREATE TABLE IF NOT EXISTS event_staff (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    event_id integer NOT NULL REFERENCES public.events(id) ON DELETE CASCADE,
    staff_id integer NOT NULL REFERENCES public.staff(id) ON DELETE CASCADE,
    UNIQUE (event_id, staff_id)
);
CREATE TABLE IF NOT EXISTS volunteer_master_roles (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL
);

CREATE TABLE IF NOT EXISTS volunteer_roles (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    category_id integer NOT NULL REFERENCES public.volunteer_master_roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS volunteer_slots (
    slot_id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    role_id integer NOT NULL REFERENCES public.volunteer_roles(id) ON DELETE CASCADE,
    start_time time without time zone NOT NULL,
    end_time time without time zone NOT NULL,
    max_volunteers integer NOT NULL,
    is_wednesday_slot boolean DEFAULT false,
    is_active boolean DEFAULT true
);

CREATE TABLE IF NOT EXISTS volunteers (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    first_name text NOT NULL,
    last_name text NOT NULL,
    email text UNIQUE,
    phone text,
    password text,
    user_id bigint REFERENCES public.clients(client_id)
);

CREATE TABLE IF NOT EXISTS password_setup_tokens (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_type text NOT NULL,
    user_id integer NOT NULL,
    token_hash text NOT NULL,
    expires_at timestamp NOT NULL,
    used boolean NOT NULL DEFAULT false
);

CREATE TABLE IF NOT EXISTS client_email_verifications (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    client_id bigint NOT NULL UNIQUE REFERENCES public.clients(client_id) ON DELETE CASCADE,
    email text NOT NULL,
    otp_hash text NOT NULL,
    expires_at timestamp NOT NULL
);

CREATE TABLE IF NOT EXISTS migration_example (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL
);

CREATE TABLE IF NOT EXISTS donors (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS donations (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    donor_id integer NOT NULL REFERENCES public.donors(id),
    date date NOT NULL,
    weight integer NOT NULL
);

CREATE TABLE IF NOT EXISTS client_visits (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL,
    client_id bigint REFERENCES public.clients(client_id),
    is_anonymous boolean NOT NULL DEFAULT false,
    weight_with_cart integer NOT NULL,
    weight_without_cart integer NOT NULL,
    pet_item integer NOT NULL DEFAULT 0,
    note text
);

CREATE TABLE IF NOT EXISTS surplus_log (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL,
    type text NOT NULL CHECK (type IN ('BREAD','CANS')),
    count integer NOT NULL,
    weight integer NOT NULL
);

CREATE TABLE IF NOT EXISTS pig_pound_log (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL,
    weight integer NOT NULL
);

CREATE TABLE IF NOT EXISTS outgoing_receivers (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS outgoing_donation_log (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    receiver_id integer NOT NULL REFERENCES public.outgoing_receivers(id),
    date date NOT NULL,
    weight integer NOT NULL,
    note text
);

CREATE TABLE IF NOT EXISTS warehouse_overall (
    year integer NOT NULL,
    month integer NOT NULL CHECK (month BETWEEN 1 AND 12),
    donations integer NOT NULL DEFAULT 0,
    surplus integer NOT NULL DEFAULT 0,
    pig_pound integer NOT NULL DEFAULT 0,
    outgoing_donations integer NOT NULL DEFAULT 0,
    PRIMARY KEY (year, month)
);
CREATE TABLE IF NOT EXISTS app_config (
    key text PRIMARY KEY,
    value text NOT NULL
);

CREATE TABLE IF NOT EXISTS donor_aggregations (
    year integer NOT NULL,
    month integer NOT NULL CHECK (month BETWEEN 1 AND 12),
    donor_id integer NOT NULL REFERENCES public.donors(id),
    total integer NOT NULL DEFAULT 0,
    PRIMARY KEY (year, month, donor_id)
);

CREATE TABLE IF NOT EXISTS volunteer_trained_roles (
    volunteer_id integer NOT NULL,
    role_id integer NOT NULL,
    category_id integer NOT NULL REFERENCES public.volunteer_master_roles(id),
    PRIMARY KEY (volunteer_id, role_id),
    FOREIGN KEY (volunteer_id) REFERENCES public.volunteers(id) ON DELETE CASCADE,
    FOREIGN KEY (role_id) REFERENCES public.volunteer_roles(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS volunteer_badges (
    volunteer_id integer NOT NULL REFERENCES public.volunteers(id) ON DELETE CASCADE,
    badge_code text NOT NULL,
    awarded_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (volunteer_id, badge_code)
);

CREATE TABLE IF NOT EXISTS refresh_tokens (
    token_id uuid PRIMARY KEY,
    subject text NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS pay_periods (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    start_date date NOT NULL,
    end_date date NOT NULL,
    CONSTRAINT pay_periods_unique_period UNIQUE (start_date, end_date)
);

CREATE TABLE IF NOT EXISTS timesheets (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    staff_id integer NOT NULL REFERENCES public.staff(id) ON DELETE CASCADE,
    start_date date NOT NULL,
    end_date date NOT NULL,
    submitted_at timestamp without time zone,
    approved_at timestamp without time zone,
    CONSTRAINT timesheets_staff_period_unique UNIQUE (staff_id, start_date, end_date)
);

CREATE TABLE IF NOT EXISTS timesheet_days (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    timesheet_id integer NOT NULL REFERENCES public.timesheets(id) ON DELETE CASCADE,
    work_date date NOT NULL,
    expected_hours integer NOT NULL,
    reg_hours integer NOT NULL DEFAULT 0,
    ot_hours integer NOT NULL DEFAULT 0,
    stat_hours integer NOT NULL DEFAULT 0,
    sick_hours integer NOT NULL DEFAULT 0,
    vac_hours integer NOT NULL DEFAULT 0,
    note text,
    locked_by_rule boolean NOT NULL DEFAULT false,
    locked_by_leave boolean NOT NULL DEFAULT false,
    CONSTRAINT timesheet_days_timesheet_date_unique UNIQUE (timesheet_id, work_date)
);

CREATE TABLE IF NOT EXISTS leave_requests (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    staff_id integer NOT NULL REFERENCES public.staff(id) ON DELETE CASCADE,
    start_date date NOT NULL,
    end_date date NOT NULL,
    status varchar(20) NOT NULL DEFAULT 'pending',
    reason text,
    created_at timestamp without time zone NOT NULL DEFAULT now(),
    updated_at timestamp without time zone NOT NULL DEFAULT now()
);

CREATE TABLE IF NOT EXISTS new_clients (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name text NOT NULL,
    email text,
    phone text,
    created_at timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS bookings (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    user_id bigint,
    slot_id integer,
    new_client_id integer,
    status text NOT NULL CHECK (status IN ('approved', 'cancelled', 'no_show', 'visited')),
    request_data text,
    note text,
    date date,
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    is_staff_booking boolean DEFAULT false,
    reschedule_token text,
    FOREIGN KEY (slot_id) REFERENCES public.slots(id),
    FOREIGN KEY (user_id) REFERENCES public.clients(client_id),
    FOREIGN KEY (new_client_id) REFERENCES public.new_clients(id) ON DELETE SET NULL
);

CREATE TABLE IF NOT EXISTS breaks (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    day_of_week integer NOT NULL,
    slot_id integer NOT NULL,
    reason text,
    UNIQUE (day_of_week, slot_id),
    FOREIGN KEY (slot_id) REFERENCES public.slots(id)
);

CREATE TABLE IF NOT EXISTS blocked_slots (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL,
    slot_id integer NOT NULL,
    reason text,
    UNIQUE (date, slot_id),
    FOREIGN KEY (slot_id) REFERENCES public.slots(id)
);

CREATE TABLE IF NOT EXISTS recurring_blocked_slots (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    day_of_week integer NOT NULL CHECK (day_of_week BETWEEN 0 AND 6),
    week_of_month integer NOT NULL CHECK (week_of_month BETWEEN 1 AND 5),
    slot_id integer NOT NULL REFERENCES public.slots(id),
    reason text,
    UNIQUE (day_of_week, week_of_month, slot_id)
);

CREATE TABLE IF NOT EXISTS holidays (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    date date NOT NULL UNIQUE,
    reason text
);

CREATE TABLE IF NOT EXISTS volunteer_recurring_bookings (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    volunteer_id integer NOT NULL REFERENCES public.volunteers(id) ON DELETE CASCADE,
    slot_id integer NOT NULL REFERENCES public.volunteer_slots(slot_id) ON DELETE CASCADE,
    start_date date NOT NULL,
    end_date date,
    pattern text NOT NULL CHECK (pattern IN ('daily','weekly')),
    days_of_week integer[] NOT NULL DEFAULT ARRAY[]::integer[],
    active boolean NOT NULL DEFAULT true
);

CREATE TABLE IF NOT EXISTS volunteer_bookings (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    volunteer_id integer NOT NULL,
    slot_id integer NOT NULL,
    date date NOT NULL,
    status text DEFAULT 'approved' NOT NULL CHECK (status IN ('approved', 'cancelled', 'no_show', 'completed')),
    reason text,
    CHECK (status <> 'cancelled' OR reason IS NOT NULL),
    created_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    reschedule_token text,
    recurring_id integer REFERENCES public.volunteer_recurring_bookings(id) ON DELETE SET NULL,
    FOREIGN KEY (slot_id) REFERENCES public.volunteer_slots(slot_id) ON DELETE CASCADE,
    FOREIGN KEY (volunteer_id) REFERENCES public.volunteers(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS email_queue (
    id integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    recipient text NOT NULL,
    template_id integer NOT NULL,
    params jsonb NOT NULL DEFAULT '{}',
    retries integer NOT NULL DEFAULT 0,
    next_attempt timestamp without time zone NOT NULL DEFAULT CURRENT_TIMESTAMP
);
`);

  await client.query(`DROP VIEW IF EXISTS v_timesheet_totals;`);
  await client.query(`DROP VIEW IF EXISTS v_timesheet_expected;`);
  await client.query(`DROP VIEW IF EXISTS v_timesheet_balance;`);
  await client.query(`
    CREATE OR REPLACE VIEW v_timesheet_totals AS
      SELECT t.id AS timesheet_id,
             COALESCE(SUM(td.reg_hours + td.ot_hours + td.stat_hours + td.sick_hours + td.vac_hours), 0) AS total_hours
        FROM timesheets t
        LEFT JOIN timesheet_days td ON td.timesheet_id = t.id
       GROUP BY t.id;
  `);
  await client.query(`
    CREATE OR REPLACE VIEW v_timesheet_expected AS
      SELECT t.id AS timesheet_id,
             COALESCE(SUM(td.expected_hours), 0) AS expected_hours
        FROM timesheets t
        LEFT JOIN timesheet_days td ON td.timesheet_id = t.id
       GROUP BY t.id;
  `);
  await client.query(`
    CREATE OR REPLACE VIEW v_timesheet_balance AS
      SELECT t.id AS timesheet_id,
             COALESCE(SUM(td.ot_hours), 0) AS ot_hours,
             COALESCE(SUM(td.reg_hours + td.stat_hours + td.sick_hours + td.vac_hours - td.expected_hours), 0) AS balance_hours
        FROM timesheets t
        LEFT JOIN timesheet_days td ON td.timesheet_id = t.id
       GROUP BY t.id;
  `);
  await client.query(`DROP TRIGGER IF EXISTS trg_timesheet_day_rules ON timesheet_days;`);
  await client.query(`DROP FUNCTION IF EXISTS trg_timesheet_day_rules();`);
  await client.query(`
    CREATE OR REPLACE FUNCTION trg_timesheet_day_rules()
    RETURNS trigger AS $$
    DECLARE
      is_stat boolean;
    BEGIN
      IF TG_OP = 'UPDATE' AND (OLD.locked_by_rule OR OLD.locked_by_leave) THEN
        RAISE EXCEPTION 'Day is locked';
      END IF;

      SELECT EXISTS(SELECT 1 FROM holidays WHERE date = NEW.work_date) INTO is_stat;
      IF is_stat THEN
        NEW.stat_hours := NEW.expected_hours;
        NEW.reg_hours := 0;
        NEW.ot_hours := 0;
        NEW.sick_hours := 0;
        NEW.vac_hours := 0;
        NEW.note := NULL;
        NEW.locked_by_rule := TRUE;
      END IF;

      IF NEW.reg_hours + NEW.stat_hours + NEW.sick_hours + NEW.vac_hours > 8 THEN
        RAISE EXCEPTION 'Daily paid hours cannot exceed 8';
      END IF;

      IF NEW.reg_hours < 0 OR NEW.ot_hours < 0 OR NEW.stat_hours < 0 OR NEW.sick_hours < 0 OR NEW.vac_hours < 0 THEN
        RAISE EXCEPTION 'Hours cannot be negative';
      END IF;

      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;
  `);
  await client.query(`
    CREATE TRIGGER trg_timesheet_day_rules
    BEFORE INSERT OR UPDATE ON timesheet_days
    FOR EACH ROW EXECUTE FUNCTION trg_timesheet_day_rules();
  `);
  await client.query(`DROP FUNCTION IF EXISTS validate_timesheet_balance(integer);`);
  await client.query(`
    CREATE OR REPLACE FUNCTION validate_timesheet_balance(p_timesheet_id integer)
    RETURNS void AS $$
    DECLARE
      v_shortfall integer;
      v_ot integer;
    BEGIN
      SELECT COALESCE(SUM(td.reg_hours + td.stat_hours + td.sick_hours + td.vac_hours - td.expected_hours), 0),
             COALESCE(SUM(td.ot_hours), 0)
        INTO v_shortfall, v_ot
        FROM timesheet_days td
       WHERE td.timesheet_id = p_timesheet_id;

      IF v_shortfall < 0 AND v_ot + v_shortfall < 0 THEN
        RAISE EXCEPTION 'Shortfall % exceeds OT %', abs(v_shortfall), v_ot;
      END IF;
    END;
    $$ LANGUAGE plpgsql;
  `);

  // Indexes are managed via migrations

  // Remove duplicate slots; uniqueness enforced via migrations
  await client.query(`
    DELETE FROM slots a
    USING slots b
    WHERE a.id > b.id
      AND a.start_time = b.start_time
      AND a.end_time = b.end_time;
  `);

  // Remove duplicate volunteer slots; uniqueness enforced via migrations
  await client.query(`
    DELETE FROM volunteer_slots a
    USING volunteer_slots b
    WHERE a.slot_id > b.slot_id
      AND a.role_id = b.role_id
      AND a.start_time = b.start_time
      AND a.end_time = b.end_time;
  `);

    // Remove duplicate volunteer bookings; uniqueness enforced via migrations
    await client.query(`
      DELETE FROM volunteer_bookings a
      USING volunteer_bookings b
      WHERE a.id > b.id
        AND a.volunteer_id = b.volunteer_id
        AND a.slot_id = b.slot_id
        AND a.date = b.date
        AND a.status <> 'cancelled'
        AND b.status <> 'cancelled';
    `);
  // Insert master data
  await client.query(`
INSERT INTO slots (start_time, end_time, max_capacity) VALUES
('09:30:00', '10:00:00', 4),
('10:00:00', '10:30:00', 4),
('10:30:00', '11:00:00', 4),
('11:00:00', '11:30:00', 4),
('11:30:00', '12:00:00', 4),
('12:00:00', '12:30:00', 4),
('12:30:00', '13:00:00', 4),
('13:00:00', '13:30:00', 4),
('13:30:00', '14:00:00', 4),
('14:00:00', '14:30:00', 4),
('14:30:00', '15:00:00', 4),
('15:00:00', '15:30:00', 4),
('15:30:00', '16:00:00', 4),
('16:00:00', '16:30:00', 4),
('16:30:00', '17:00:00', 4),
('17:00:00', '17:30:00', 4),
('17:30:00', '18:00:00', 4),
('18:00:00', '18:30:00', 4),
('18:30:00', '19:00:00', 4)
ON CONFLICT (start_time, end_time) DO NOTHING;

INSERT INTO breaks (day_of_week, slot_id, reason)
SELECT b.day_of_week, s.id, b.reason
FROM (
  VALUES
    (1, '12:00:00'::time, '12:30:00'::time, 'Lunch Break'),
    (2, '12:00:00'::time, '12:30:00'::time, 'Lunch Break'),
    (3, '12:00:00'::time, '12:30:00'::time, 'Lunch Break'),
    (4, '12:00:00'::time, '12:30:00'::time, 'Lunch Break'),
    (5, '12:00:00'::time, '12:30:00'::time, 'Lunch Break'),
    (1, '12:30:00'::time, '13:00:00'::time, 'Lunch Break'),
    (2, '12:30:00'::time, '13:00:00'::time, 'Lunch Break'),
    (3, '12:30:00'::time, '13:00:00'::time, 'Lunch Break'),
    (4, '12:30:00'::time, '13:00:00'::time, 'Lunch Break'),
    (5, '12:30:00'::time, '13:00:00'::time, 'Lunch Break'),
    (3, '15:00:00'::time, '15:30:00'::time, 'Evening Break'),
    (3, '15:30:00'::time, '16:00:00'::time, 'Evening Break')
) AS b(day_of_week, start_time, end_time, reason)
JOIN slots s ON s.start_time = b.start_time AND s.end_time = b.end_time
ON CONFLICT (day_of_week, slot_id) DO NOTHING;

INSERT INTO volunteer_master_roles (id, name) VALUES
(1, 'Pantry'),
(2, 'Warehouse'),
(3, 'Gardening'),
(4, 'Administration'),
(5, 'Special Events')
ON CONFLICT DO NOTHING;

-- Ensure the sequence is aligned with the seeded IDs so that subsequent
-- inserts without explicit IDs don't collide with existing rows.
SELECT setval('volunteer_master_roles_id_seq', (SELECT COALESCE(MAX(id), 0) FROM volunteer_master_roles));

INSERT INTO volunteer_roles (id, name, category_id) VALUES
(1, 'Food Sorter', 2),
(2, 'Production Worker', 2),
(3, 'Driver Assistant', 2),
(4, 'Loading Dock Personnel', 2),
(5, 'General Cleaning & Maintenance', 2),
(6, 'Reception', 1),
(7, 'Greeter / Pantry Assistant', 1),
(8, 'Stock Person', 1),
(9, 'Gardening Assistant', 3),
(10, 'Event Organizer', 5),
(11, 'Event Resource Specialist', 5),
(12, 'Volunteer Marketing Associate', 4),
(13, 'Client Resource Associate', 4),
(14, 'Assistant Volunteer Coordinator', 4),
(15, 'Volunteer Office Administrator', 4),
(16, 'Donation Entry', 2)
ON CONFLICT (id) DO NOTHING;

-- Align sequence for volunteer_roles as well to avoid duplicate key errors
-- when new roles are created without specifying an ID.
SELECT setval('volunteer_roles_id_seq', (SELECT COALESCE(MAX(id), 0) FROM volunteer_roles));

WITH seed_slots (role_id, start_time, end_time, max_volunteers, is_wednesday_slot) AS (
  VALUES
    (1, '09:00:00'::time, '12:00:00'::time, 3, false),
    (2, '09:00:00'::time, '12:00:00'::time, 3, false),
    (3, '09:00:00'::time, '12:00:00'::time, 1, false),
    (4, '09:00:00'::time, '12:00:00'::time, 1, false),
    (5, '08:00:00'::time, '11:00:00'::time, 1, false),
    (6, '09:00:00'::time, '12:00:00'::time, 1, false),
    (6, '12:30:00'::time, '15:30:00'::time, 1, false),
    (6, '15:30:00'::time, '18:30:00'::time, 1, true),
    (7, '09:00:00'::time, '12:00:00'::time, 3, false),
    (7, '12:30:00'::time, '15:30:00'::time, 3, false),
    (7, '15:30:00'::time, '18:30:00'::time, 3, true),
    (7, '16:30:00'::time, '19:30:00'::time, 3, true),
    (8, '08:00:00'::time, '11:00:00'::time, 1, false),
    (8, '12:00:00'::time, '15:00:00'::time, 1, false),
    (9, '13:00:00'::time, '16:00:00'::time, 2, false),
    (10, '09:00:00'::time, '17:00:00'::time, 5, false),
    (11, '09:00:00'::time, '17:00:00'::time, 5, false),
    (12, '08:00:00'::time, '16:00:00'::time, 1, false),
    (13, '08:00:00'::time, '16:00:00'::time, 1, false),
    (14, '08:00:00'::time, '16:00:00'::time, 1, false),
    (15, '08:00:00'::time, '16:00:00'::time, 1, false)
)
INSERT INTO volunteer_slots (role_id, start_time, end_time, max_volunteers, is_wednesday_slot)
SELECT s.role_id, s.start_time, s.end_time, s.max_volunteers, s.is_wednesday_slot
FROM seed_slots s
WHERE NOT EXISTS (
  SELECT 1
  FROM volunteer_slots vs
  WHERE vs.role_id = s.role_id
    AND vs.start_time = s.start_time
    AND vs.end_time = s.end_time
);
`);

  await client.query(
    `INSERT INTO app_config (key, value) VALUES
      ('cart_tare','0'),
      ('bread_weight_multiplier','10'),
      ('cans_weight_multiplier','20'),
      ('volunteer_monthly_hours_goal','80')
    ON CONFLICT (key) DO NOTHING;`
  );

  const donorList = [
    'AAWARRIORS',
    'MOOSE JAW ALLICANCE CHURCH',
    'A&W',
    'AVE LIVING',
    'AVONLEA SCHOOL',
    '15 WING',
    'BENTLY',
    'BETTER HOMES & GARDENS',
    'FOOD BANK BINS',
    'BUDGET BLINDS',
    'BUILDING BLOCKS DAY CARE',
    'BULK BARN',
    'BOUNCE A LOT CASINO',
    'CAE BASE',
    'CARONPORT/BRIERCREST SCHOOL',
    'CENTRAL BUTTE UNITED CHURCH',
    'CENTRAL COLLEGIATE SCHOOL',
    'CENTRAL LUTHERAN CHURCH',
    'SHERYL SCHOLAR',
    "CHARLOTTES CATERING",
    'CHAPLIN LUTHERAN CHURCH',
    'CHURCH OF CHRIST',
    'CHURCH OF OUR LADY',
    'CHURCH OF GOD',
    'COOPERATORS',
    'COO-OP GROCERY',
    'CO-OP BIN',
    'CO-OP(GOODBUY TO HUNGER)',
    'CORNACHE UNITED CHURCH',
    'CORNERSTONE CHRISTIAN SCHOOL',
    'CONEXUS',
    'COMMUNITY GARDENS',
    'CORONACH UNITED CHURCH',
    'CULTURAL CENTER',
    'DANCE IMAGES',
    'DOEPKER INDUSTRIES',
    'EMMANUAL LUTHERAN CHURCH',
    'EMPIRE SCHOOL',
    'EXTENDICARE',
    'ELECTRIC FOG',
    'FARM CREDIT',
    'FINEFOODS PRODUCE',
    'FRATURNAL ORDER OF EAGLES',
    'FRENCH SCHOOL DAYCARE',
    'FIRST BAPTIST CHURCH',
    'FOOD BANKS SASKATCHEWAN',
    'FOOD BANKS CANADA',
    'BAILDON COLONY',
    'FCC FOOD DRIVE',
    'GIRLGUIDES',
    'GIANT TIGER',
    'GATX RAIL',
    'JUDO CLUB SASK',
    'HILLCREST APOSTOLIC CHURCH(BETTER TOGETHER FOOD DRIVE)',
    'HERITAGE INN',
    'HUNGER IN MOOSE JAW',
    'HUB MEATS',
    'HUTTERITTES COLONLY',
    'CPKC HOLIDAY TRAIN',
    'INVESTORS GROUP',
    'KEONS',
    'KINSMEN SANTA PARADE',
    'KINSMEN MOVIE NIGHT',
    'KIMS TAE KWON DO',
    'KFC',
    'KING GEORGE SCHOOL',
    'LIVE STRONG FITNESS',
    'LABOUR DISTRIC COUNCIL',
    'LINDALE SCHOOL',
    'HUNGER IN MOOSE JAW',
    'MANKOTA UNITED CHURCH',
    'MAGIC BY CHRIS',
    'MINTO UNITED CHURCH',
    'MJ MINOR FOOTBALL',
    'MJ TRISKELIONS REGIONAL COUNCIL',
    'MJREFINERY',
    'MOOSE JAW CULTURAL CENTER',
    'MJWARRIORS',
    'MORTLACH SCHOOL',
    'MULLBERRY ESTATES',
    'MOSAIC FOOD FARM',
    'NUTTERS',
    'PAARISH & HEIMBECKER',
    'PARADE HOMETOWN',
    'PAMPERED CHEF',
    'PALLISER HEIGHTS SCHOOL',
    'PEACOCK SCHOOL',
    'PIONEER LODGE',
    'PETFOOD/PETVALUE',
    'PRAIRIE OASIS',
    'PRINCESS TEA',
    'PRINCE ARTHUR SCHOOL',
    'PRIVATE DONATIONS',
    'RIVERSIDE MISSION(SOULS HARBOUR)',
    'PRODUC PRIVATE HUTTERITE COLONIESE/5 FT CHALL',
    'PRODUCE SAFEWAY',
    'PRODUCE WALMART',
    'PRODUCE PRIVATE',
    'PRODUCE BTFD',
    'PRODUC PHARMASAVE',
    'FOOD SHARE REGINA',
    'NO FRILLS',
    'ROYAL BANK',
    'NEXT GEN CAR SHOW(SPRING)',
    'MAKE SPACE STORAGE',
    'NEXT GEN CAR SHOW (FALL)',
    'RIVERVIEW COLLEGIATE',
    'UNION SOUTH STEEL',
    'UNIION BBQ',
    'UNION GROCERY',
    'SACRED HEART SCHOOL',
    'SAFEWAY',
    'SAFEWAY (BINS)',
    'SASKTEL',
    'SASK ENERGY',
    'SASK WATER',
    'SASK SPCA',
    'SECOND CHANCE THRIFT STORE',
    'SIAST',
    'SEIU WEST',
    'SHOOPER DRUG MART (SECOND HARVEST)',
    'SOBEYS',
    'STARBUCKS',
    'ST.AGNUS SCHOOL',
    'ST. AIDEN SCHOOL',
    'ST. ANDREW CHURCH',
    'ST. BARNABAS CHURCH',
    'ST.JOSEPHS CHURCH',
    "ST.MARGARET SCHOOL",
    'ST.MARKS CHURCH',
    "ST.MARY'S SCHOOL",
    'ST.MICHAELS SCHOOL',
    'SUNNINGDALE SCHOOL',
    'SUPERSTORE SECOND HARVEST',
    'SUPERSTORE BIN',
    'SUPERSTORE(SPRING)FEED MORE FAMILIES',
    'SUPERSTORE(FILL THE VAN)',
    'SUPERSTORE',
    'SUPERSTORE (FALL)',
    'TRADE SHOW',
    'TRANSITION HOUSE',
    'TEMPLE GARDENS',
    'TOWN N COUNTRY MALL',
    'TRINITY UNITED CHURCH',
    'TWISTED SISTER ICE CREAM PARLOR',
    'VANIER COLLEGIATE',
    'VEROBAS',
    'VICTORIA TOWERS',
    'VILLAGE OF TUXFORD',
    'WAREHOUSE ONE JEANS',
    'WALMART',
    'WALMART(FIGHT HUNGER SPARK CHANGE)',
    'WALKAMOW VALLEY',
    'WELLS CAMERA A& SOUND',
    'WESTMOUNT SCHOOL',
    'WINDSOR SALT',
    'WILLIAM GRAYSON SCHOOL',
    'ZOMBIE WALK',
    'ZION CHURCH',
  ];
  const donors = [...new Set(donorList)];
  const hasFirstNameColumn = await client
    .query(
      `SELECT 1 FROM information_schema.columns WHERE table_name = 'donors' AND column_name = 'first_name'`,
    )
    .then(res => (res.rowCount ?? 0) > 0);

  if (hasFirstNameColumn) {
    const donorValues: string[] = [];
    const params: string[] = [];
    donors.forEach((name, index) => {
      const [firstName, ...lastNameParts] = name.split(' ');
      const lastName = lastNameParts.join(' ');
      const email = `donor${index + 1}@example.com`;
      params.push(firstName, lastName, email);
      donorValues.push(
        `($${index * 3 + 1}, $${index * 3 + 2}, $${index * 3 + 3})`,
      );
    });
    await client.query(
      `INSERT INTO donors (first_name, last_name, email) VALUES ${donorValues.join(',')} ON CONFLICT (email) DO NOTHING;`,
      params,
    );
  } else {
    const donorValues: string[] = [];
    donors.forEach((_, index) => {
      donorValues.push(`($${index + 1})`);
    });
    await client.query(
      `INSERT INTO donors (name) VALUES ${donorValues.join(',')} ON CONFLICT (name) DO NOTHING;`,
      donors,
    );
  }
  logger.info('Database setup complete');
  await client.end();
}
